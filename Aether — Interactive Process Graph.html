<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Aether — Interactive Node Graph</title>
<style>
  :root{
    --bg:#071028; --muted:#8fb7d8; --panel:#071831;
    --accent:#5c8cff; --glass: rgba(255,255,255,0.03);
    --node-fill: #071a2a; --node-ring: #05273e; --node-stroke: #224b7a;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial; -webkit-font-smoothing:antialiased;}
  .wrap{display:flex;flex-direction:row;height:100vh;gap:12px;padding:12px;box-sizing:border-box}
  .viz{flex:1;min-width:360px;min-height:300px;border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#041323,#08182b);box-shadow:0 8px 30px rgba(0,0,0,.6);position:relative}
  svg{width:100%;height:100%;display:block;touch-action:none;user-select:none}
  .panel{width:420px;max-width:45vw;min-width:260px;background:var(--panel);border-radius:12px;padding:16px;color:#dff1ff;box-shadow:0 8px 30px rgba(0,0,0,.6);overflow:auto}
  h3{margin:6px 0 10px 0;font-weight:600;color:#eaf6ff}
  .nodeGroup{cursor:grab; will-change:transform;}
  .nodeGroup.dragging{cursor:grabbing;}
  .nodeRing{fill:none;stroke:var(--node-ring);stroke-width:12;opacity:0.55;}
  .nodeCore{fill:var(--node-fill);stroke:var(--node-stroke);stroke-width:2;}
  .labelText{fill:#dff1ff;font-weight:700;font-size:13px;text-anchor:middle;pointer-events:none}
  .flow{stroke-linecap:round;stroke-linejoin:round;opacity:0.92;pointer-events:none}
  .packet{pointer-events:none}
  .substep{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;margin-bottom:8px;border:1px solid rgba(255,255,255,0.03)}
  .small-btn{background:#0e2b44;border:none;padding:6px 8px;border-radius:8px;color:#dff1ff;cursor:pointer}
  .trace{font-family:monospace;background:rgba(0,0,0,0.12);padding:8px;border-radius:6px;margin-top:8px;white-space:pre-wrap;font-size:12px;color:#bfe6ff;max-height:260px;overflow:auto}
  .inspector { margin-top:12px; background: linear-gradient(180deg, rgba(9,17,28,0.6), rgba(6,12,20,0.6)); padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04) }
  .micrograph{width:100%;height:200px;background:rgba(0,0,0,0.06);border-radius:6px;margin-top:8px;overflow:hidden;position:relative}
  .hint{position:absolute;left:12px;bottom:12px;color:#9fd8ff;background:rgba(0,0,0,0.25);padding:6px 8px;border-radius:10px;font-size:13px}
  @media (max-width:980px){ .wrap{flex-direction:column} .panel{width:100%;max-width:100%;min-width:0} }
  .nodeGroup .visual{transform-origin:center center; transition:transform .18s cubic-bezier(.2,.9,.2,1), filter .18s}
  .nodeGroup:hover .visual{transform:scale(1.06); filter:brightness(1.05) saturate(1.05);}
</style>
</head>
<body>
<div class="wrap">
  <div class="viz" id="viz">
    <svg id="svg" xmlns="http://www.w3.org/2000/svg" aria-label="Aether interactive graph">
      <defs>
        <linearGradient id="bg" x1="0" x2="1"><stop offset="0" stop-color="#041323"/><stop offset="1" stop-color="#071028"/></linearGradient>
        <filter id="glow"><feGaussianBlur stdDeviation="6" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
      </defs>
      <rect width="100%" height="100%" fill="url(#bg)"/>
      <g id="flows"></g>
      <g id="nodes"></g>
      <g id="packets"></g>
      <g id="labels"></g>
    </svg>
    <div class="hint">Created by <strong>Patrick U. Clement</strong></div>
  </div>

  <div class="panel">
    <h3>Aether — Interactive Process Graph</h3>
    <div style="display:flex;gap:8px;align-items:center">
      <div style="flex:1">Drag nodes to reposition. Click a node to inspect internals and run microcalls.</div>
      <button id="reset" class="small-btn">Reset View</button>
    </div>
    <p>P.S. I'm finishing this at 2am so if i find any bugs or errors I made later I'll fix them </p>
    <div style="margin-top:12px">
      <div style="margin-bottom:8px"><button id="runDemo" class="small-btn">Run Demo Trace</button></div>
      <div id="details"></div>
      <div id="inspector" class="inspector" style="display:none">
        <strong id="inspectorTitle"></strong>
        <div id="inspectorInfo" style="margin-top:8px;color:#bfe6ff"></div>
        <div style="margin-top:8px;display:flex;gap:8px">
          <button id="openMicro" class="small-btn">Open Micrograph</button>
          <button id="playMicro" class="small-btn">Play Microcalls</button>
        </div>
        <div id="microArea" class="micrograph"></div>
      </div>
      <div id="trace" class="trace" style="display:none"></div>
    </div>
  </div>
</div>

<script>
/* -------------------- Core setup -------------------- */
const svg = document.getElementById('svg');
const flowsG = document.getElementById('flows');
const nodesG = document.getElementById('nodes');
const packetsG = document.getElementById('packets');

const details = document.getElementById('details');
const inspector = document.getElementById('inspector');
const inspectorTitle = document.getElementById('inspectorTitle');
const inspectorInfo = document.getElementById('inspectorInfo');
const microArea = document.getElementById('microArea');
const openMicro = document.getElementById('openMicro');
const playMicro = document.getElementById('playMicro');
const trace = document.getElementById('trace');

const resetBtn = document.getElementById('reset');
const runDemoBtn = document.getElementById('runDemo');

/* -------------------- Responsive viewBox -------------------- */
let view = {x:0,y:0,w:1600,h:900};
function setView(){ svg.setAttribute('viewBox', `${view.x} ${view.y} ${view.w} ${view.h}`); }
function adjustViewForScreen(){
  const w = window.innerWidth;
  const h = window.innerHeight;
  const aspect = 1600/900;
  if(w/h < aspect){ view.w = 1600; view.h = 1600/(w/h); }
  else { view.h = 900; view.w = 900*(w/h); }
  view.x=0; view.y=0; setView();
}
window.addEventListener('resize', adjustViewForScreen);
adjustViewForScreen();

/* Convert screen coordinates to SVG */
function screenToSvg(evt){
  const pt = svg.createSVGPoint();
  pt.x = evt.clientX; pt.y = evt.clientY;
  const ctm = svg.getScreenCTM().inverse();
  return pt.matrixTransform(ctm);
}

/* -------------------- Graph data -------------------- */
const nodesData = [
  { id:'INPUT', x:140, y:150, subs:['tokenizer_normalizer','parser_dependency_pos_phrase','embedding_mapper','intent_classifier','semantic_similarity','ner_relation_extractor'], libs:['tokenizers','spaCy','transformers'] },
  { id:'MEMORY', x:520, y:150, subs:['triplet_graph_store','crud_ops','weighted_edges','indexing_hashing','persistence_json_graphdb','retrieval_by_relevance'], libs:['networkx','rdflib','sqlite'] },
  { id:'REASONER', x:520, y:420, subs:['symbolic_inference','causal_chain_constructor','hypothesis_generator','goal_planner','meta_reasoning','scoring_confidence'], libs:['sympy','custom_infer'] },
  { id:'SELF_MODEL', x:920, y:320, subs:['introspection','consistency_validation','confidence_adjustment','identity_memory','self_updates','error_reflection'], libs:['numpy','custom_meta'] },
  { id:'RESPONSEGEN', x:1260, y:260, subs:['compositional_grammar_engine','templates_rule_syntax','word_meaning_dict','stochastic_variation','tense_detection','aggregation_weighting','nl_mapping'], libs:['jinja2'] },
  { id:'OUTPUT', x:1460, y:320, subs:['formatting','serialization_json','dispatch_ui_api'], libs:['json','http'] }
];

const flowPairs = [
  ['INPUT','MEMORY'], ['MEMORY','REASONER'], ['REASONER','SELF_MODEL'], ['SELF_MODEL','RESPONSEGEN'], ['RESPONSEGEN','OUTPUT']
];

const palettes = [
  ['#13c2ff','#9f5bff','#ff6ec7'],
  ['#7effc7','#00d09c','#00a88a'],
  ['#8eb6ff','#6f9cff','#9d7aff'],
  ['#ffdd57','#ff7a00','#ff3d00']
];

let pathMap=[];

/* -------------------- Helper functions -------------------- */
function makePath(from,to,curvature=0.36){
  const fx=from.x, fy=from.y, tx=to.x, ty=to.y;
  const dx=tx-fx, dy=ty-fy;
  const cx1=fx + dx*0.3 + dy*curvature;
  const cy1=fy + dy*0.3 - dx*curvature;
  const cx2=fx + dx*0.7 - dy*curvature;
  const cy2=fy + dy*0.7 + dx*curvature;
  return `M ${fx} ${fy} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${tx} ${ty}`;
}

function createGradient(colors){
  const id='g'+(Math.random()*1e6|0);
  const defs = svg.querySelector('defs');
  const lg = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
  lg.setAttribute('id',id); lg.setAttribute('x1','0'); lg.setAttribute('y1','0'); lg.setAttribute('x2','1'); lg.setAttribute('y2','0');
  colors.forEach((c,i)=>{
    const stop = document.createElementNS('http://www.w3.org/2000/svg','stop');
    stop.setAttribute('offset', (i/(colors.length-1))*100 + '%');
    stop.setAttribute('stop-color', c);
    lg.appendChild(stop);
  });
  defs.appendChild(lg);
  return id;
}

/* -------------------- Draw flows -------------------- */
function drawFlows(){
  flowPairs.forEach((pair,idx)=>{
    const from = nodesData.find(n=>n.id===pair[0]);
    const to = nodesData.find(n=>n.id===pair[1]);
    const pal = palettes[idx % palettes.length];
    for(let layer=0;layer<4;layer++){
      const pathEl = document.createElementNS('http://www.w3.org/2000/svg','path');
      const d = makePath(from,to,0.22+layer*0.06);
      pathEl.setAttribute('d', d);
      pathEl.setAttribute('stroke','url(#'+createGradient(pal)+')');
      pathEl.setAttribute('stroke-width',6-layer);
      pathEl.setAttribute('fill','none');
      if(layer===0) pathEl.setAttribute('filter','url(#glow)');
      pathEl.classList.add('flow');
      flowsG.appendChild(pathEl);
      pathMap.push({from:pair[0],to:pair[1],path:pathEl,layer,endpoints:{sx:from.x,sy:from.y,ex:to.x,ey:to.y}});
    }
  });
}

function updateFlowsForNode(nodeId){
  pathMap.forEach(e=>{
    if(e.from===nodeId || e.to===nodeId){
      const from = nodesData.find(n=>n.id===e.from);
      const to = nodesData.find(n=>n.id===e.to);
      e.path.setAttribute('d', makePath(from,to,0.22+e.layer*0.06));
      e.endpoints={sx:from.x,sy:from.y,ex:to.x,ey:to.y};
    }
  });
}

/* -------------------- Draw nodes -------------------- */
function drawNodes(){
  nodesData.forEach(n=>{
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('class','nodeGroup'); g.setAttribute('transform',`translate(${n.x},${n.y})`);
    g.dataset.id=n.id;

    const visual = document.createElementNS('http://www.w3.org/2000/svg','g');
    visual.setAttribute('class','visual');

    const ring = document.createElementNS('http://www.w3.org/2000/svg','circle'); ring.setAttribute('r',56); ring.setAttribute('class','nodeRing');
    const core = document.createElementNS('http://www.w3.org/2000/svg','circle'); core.setAttribute('r',30); core.setAttribute('class','nodeCore');

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('y',72); label.setAttribute('class','labelText'); label.textContent = n.id.replace('_',' ');

    visual.appendChild(ring); visual.appendChild(core); g.appendChild(visual); g.appendChild(label);
    nodesG.appendChild(g);
    n.el=g; n.visual=visual; n.label=label;

    g.addEventListener('click', e=>{ if(g.dataset.dragging==='1'){ g.dataset.dragging='0'; return; } openInspector(n); e.stopPropagation(); });

    g.addEventListener('pointerdown', evt=>{
      evt.preventDefault(); g.setPointerCapture(evt.pointerId);
      g.classList.add('dragging'); g.dataset.dragging='0';
      const start = screenToSvg(evt); const startX=start.x, startY=start.y; const origX=n.x, origY=n.y;
      function move(ev){ const cur=screenToSvg(ev); const dx=cur.x-startX, dy=cur.y-startY; n.x=origX+dx; n.y=origY+dy; g.setAttribute('transform',`translate(${n.x},${n.y})`); n.label && n.label.setAttribute('y',72); updateFlowsForNode(n.id); g.dataset.dragging='1'; }
      function up(ev){ svg.removeEventListener('pointermove',move); svg.removeEventListener('pointerup',up); try{ g.releasePointerCapture(evt.pointerId);}catch(e){} g.classList.remove('dragging'); }
      svg.addEventListener('pointermove',move); svg.addEventListener('pointerup',up);
    });
  });
}

/* -------------------- Inspector -------------------- */
function openInspector(node){
  details.innerHTML=''; inspector.style.display='block';
  inspectorTitle.textContent=node.id.replace('_',' ')+' — Substeps';
  inspectorInfo.textContent='Dependencies: '+(node.libs||[]).join(', ');
  const frag=document.createDocumentFragment();
  node.subs.forEach(s=>{
    const box=document.createElement('div'); box.className='substep';
    const pretty=s.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase());
    box.innerHTML=`<div style="display:flex;justify-content:space-between;align-items:center"><div><strong>${pretty}</strong><div style="color:#bfe6ff;margin-top:6px;font-size:13px">${describe(s)}</div></div><div><button data-sub="${s}" data-node="${node.id}" class="small-btn">Run</button></div></div>`;
    frag.appendChild(box);
  });
  details.appendChild(frag);
  details.querySelectorAll('button.small-btn').forEach(btn=>{ btn.addEventListener('click', e=>{ runSubstep(btn.dataset.node, btn.dataset.sub); }); });
}

function describe(s){
  const map={
    tokenizer_normalizer:'Split tokens, normalize casing, strip noise.',
    parser_dependency_pos_phrase:'Build dependency graph, POS tags, phrase chunks.',
    embedding_mapper:'Map tokens to semantic vectors.',
    intent_classifier:'Determine user intent (probabilities).',
    semantic_similarity:'Score semantic similarity to memories/concepts.',
    ner_relation_extractor:'Extract entities and candidate relations.',
    triplet_graph_store:'Store and index Subject–Relation–Object triples.',
    crud_ops:'Create/Read/Update/Delete graph fragments.',
    weighted_edges:'Assign/update weights (confidence, recency).',
    indexing_hashing:'Fast lookup via indexes and hashes.',
    persistence_json_graphdb:'Serialize snapshots to JSON/graphdb.',
    retrieval_by_relevance:'Retrieve top-K relevant triples.',
    symbolic_inference:'Reason over logical/casual chains.',
    causal_chain_constructor:'Build cause→effect chains.',
    hypothesis_generator:'Propose likely hypotheses for goals.',
    goal_planner:'Plan actions to achieve targets.',
    meta_reasoning:'Reflect on reasoning patterns.',
    scoring_confidence:'Assign confidence to conclusions.',
    introspection:'Analyze past outputs for patterns.',
    consistency_validation:'Check internal consistency.',
    confidence_adjustment:'Update confidence in predictions.',
    identity_memory:'Maintain self-knowledge.',
    self_updates:'Update internal models from experience.',
    error_reflection:'Log and learn from errors.',
    compositional_grammar_engine:'Compose sentences via grammar rules.',
    templates_rule_syntax:'Templates and rules for syntax expansion.',
    word_meaning_dict:'Lookup word meanings and variations.',
    stochastic_variation:'Introduce slight randomization for variability.',
    tense_detection:'Detect tense of messages.',
    aggregation_weighting:'Aggregate signals and weight importance.',
    nl_mapping:'Map internal representation to natural language.',
    formatting:'Format output correctly.',
    serialization_json:'Serialize to JSON.',
    dispatch_ui_api:'Send to UI or API endpoints.'
  };
  return map[s]||'Executes specific substep logic.';
}

function runSubstep(nodeId, substep){ trace.style.display='block'; trace.textContent+=`\n[${nodeId}] Running ${substep}... done.`; trace.scrollTop=trace.scrollHeight; }

/* -------------------- Packets (animated circles along flows) -------------------- */
const packets = [];
function spawnPacket(pathEl){
  const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
  circle.setAttribute('r',6); circle.setAttribute('fill','#5c8cff'); circle.classList.add('packet');
  packetsG.appendChild(circle);
  packets.push({el:circle,path:pathEl,t:0,speed:0.008+Math.random()*0.012});
}
function animatePackets(){
  packets.forEach(p=>{
    p.t+=p.speed;
    if(p.t>1){ p.t=0; }
    const len=p.path.getTotalLength(); const pt=p.path.getPointAtLength(p.t*len);
    p.el.setAttribute('cx',pt.x); p.el.setAttribute('cy',pt.y);
  });
  requestAnimationFrame(animatePackets);
}

/* -------------------- Buttons -------------------- */
resetBtn.addEventListener('click', adjustViewForScreen);
runDemoBtn.addEventListener('click',()=>{
  trace.style.display='block';
  trace.textContent='Demo trace started...\n';
  let i=0;
  function step(){ if(i>=nodesData.length) return; const n=nodesData[i]; n.subs.forEach(s=>runSubstep(n.id,s)); i++; setTimeout(step,300); }
  step();
});

/* -------------------- Initialization -------------------- */
drawFlows();
drawNodes();
flowPairs.forEach(p=>spawnPacket(flowsG.querySelector('path')));
animatePackets();

</script>
</body>
</html>
